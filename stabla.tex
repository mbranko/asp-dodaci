\documentclass[11pt,a4paper]{article}

\usepackage{ifxetex}
\RequireXeTeX

\usepackage[a4paper,tmargin=1in,bmargin=1.3in,lmargin=1in,rmargin=1in]{geometry}

% bookmarks in PDF
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue,bookmarksopen=true]{hyperref}
\usepackage[depth=3]{bookmark}
% open file with zoom to page width
\hypersetup{pdfstartview={FitH top}}

% math package
\usepackage{amsmath}

% customizing fonts
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{titlesec}
\setsansfont{Fira Sans}
\setmonofont{JetBrains Mono NL}[Scale=0.8]
\setmainfont{Dijakritika}
\titleformat*{\section}{\Large\bfseries\sffamily}
\titleformat*{\subsection}{\bfseries\sffamily}

% image handling
\usepackage{graphicx}
\usepackage{forest}
\usepackage{tikz}
\usetikzlibrary{arrows,petri,topaths,arrows.meta,automata,calc,shapes.multipart,chains,shapes.gates.logic.US,matrix}
\usepackage{tkz-berge}
\usepackage[position=top]{subfig}
\tikzstyle{branch}=[fill,shape=circle,minimum size=3pt,inner sep=0pt]

% syntax highligting
\usepackage{minted}

% custom headers and footers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\chead{ASP primeri}
\cfoot{Page \thepage}
\setlength{\headheight}{46pt}

\frenchspacing

\begin{document}

\section{Jednostruko spegnute liste}

Za sve zadatke u ovom odeljku, osim ako nije drugačije navedeno, svaki čvor ima
dva atributa -- polje sa podatkom i polje sa pokazivačem (adresom) na sledeći
čvor u listi. Polje za sledeći kod poslednjeg elementa ima vrednost
\texttt{None}. Čvor može biti predstavljen sledećom klasom:

\begin{minted}[frame=lines]{python}
class ListNode:
    def __init__(self, data=0, next_node=None)
        self.data = data 
        self.next = next_node  
\end{minted}  

Osnovne operacije nad listom -- pretraga, dodavanje i uklanjanje -- mogu se
implementirati na sledeći način.

\begin{minted}[frame=lines]{python}
def search_list(L, key): 
    while L and L.data != key:
        L = L.next
    # If key was not present in the List, L will have become null 
    return L


def insert_after(node, new_node):
    new_node.next = node.next
    node.next = new_node


# Delete the node past this one. Assume node is not a tail 
def delete_after(node):
    node.next = node.next.next
\end{minted}  

Ispod haube, Pajton tip \texttt{list} se tipično implementira kao niz sa
automatskom promenom veličine. Ovaj odeljak se bavi jednostruko i dvostruko
spregnutim listama koje nemaju standardni tip u Pajtonu. Definisaćemo sopstvene
tipove koje predstavljaju ovakve liste. Neke od operacije nad listama obuhvataju
vraćanje glave ili repa, dodavanje elementa na početak ili kraj liste, vraćanje
elementa koji se nalazi na početku ili kraju, uklanjanje sa početka ili kraja,
ili bilo kog elementa liste.

\subsection{Obrtanje podliste}

Ovaj problem se bavi obrtanjem podliste u okviru liste. Slike
\ref{fig:reversesublist1} i \ref{fig:reversesublist2} predstavljaju primer ove
operacije.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[list/.style={
        rectangle split, 
        rectangle split parts=2,
        draw, 
        rectangle split horizontal,        
        prefix after command={\pgfextra{\tikzset{every label/.style={
          gray,
          below,
          yshift=-27,
          scale=0.6}}}}
      }, 
      >=stealth, 
      start chain, 
      pin edge = {
        Straight Barb-, 
        shorten <=1mm,semithick
      }
    ]
    \node[list,on chain,pin=180:L,label=0x2700] (A) {11};
    \node[list,on chain,label=0x2430] (B) {3};
    \node[list,on chain,label=0x1240] (C) {5};
    \node[list,on chain,label=0x1830] (D) {7};
    \node[list,on chain,label=0x1000] (E) {2};
    \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
    \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
    \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
    \draw[*->] let \p1 = (D.two), \p2 = (D.center) in (\x1,\y2) -- (E);
  \end{tikzpicture}
  \caption{Početno stanje liste}
  \label{fig:reversesublist1}
\end{figure}

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[list/.style={
        rectangle split, 
        rectangle split parts=2,
        draw, 
        rectangle split horizontal,        
        prefix after command={\pgfextra{\tikzset{every label/.style={
          gray,
          below,
          yshift=-27,
          scale=0.6}}}}
      }, 
      >=stealth, 
      start chain, 
      pin edge = {
        Straight Barb-, 
        shorten <=1mm,semithick
      }
    ]
    \node[list,on chain,pin=180:L,label=0x2700] (A) {11};
    \node[list,on chain,label=0x1830] (D) {7};
    \node[list,on chain,label=0x1240] (C) {5};
    \node[list,on chain,label=0x2430] (B) {3};
    \node[list,on chain,label=0x1000] (E) {2};
    \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (D);
    \draw[*->] let \p1 = (D.two), \p2 = (B.center) in (\x1,\y2) -- (C);
    \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (B);
    \draw[*->] let \p1 = (B.two), \p2 = (D.center) in (\x1,\y2) -- (E);
  \end{tikzpicture}
  \caption{Lista sa obrnutom podlistom}
  \label{fig:reversesublist2}
\end{figure}

\textbf{Zadatak:} Napisati program koji dobija jednostruko spregnutu listu $L$ i
dva cela broja $s$ i $f$ kao argumente i obrće redosled čvorova u listi počevši
od $s$-tog čvora do $f$-tog čvora, uključivo. Čvorovi su numerisani počevši od
1, tj. glava liste ima redni broj 1. Nije dozvoljeno zauzimanje memorije za
dodatne čvorove.

\textbf{Savet:} Fokusirajte se na pokazivače na sledeći čvor koje treba
ažurirati.

\textbf{Rešenje:} Direktno rešenje je da se izdvoji podlista, obrne joj se
redosled, i vrati se nalaz u polaznu listu. Nedostatak ovog pristupa je da su
potrebna dva prolaska kroz podlistu.

Operacija se može izvesti u jednom prolazu kombinovanjem identifikacije podliste
sa njenim iteriranjem. Identifikovaćemo početak podliste iteriranjem kroz
čvorove do $s$-tog čvora. Kada dođemo do $s$-tog čvora, započinjemo obrtanje i
nastavljamo sa brojanjem. Kada dođemo do $f$-tog čvora, zaustavljamo obrtanje i
vezujemo obrnutu podlistu sa ostatkom početne liste.

\begin{minted}[frame=lines]{python}
def reverse_sublist(L, start, finish): 
    dummy_head = sublist_head = ListNode(0, L) 
    for _ in range(1, start):
        sublist_head = sublist_head.next

    # Reverses sublist
    sublist_iter = sublist_head.next 
    for _ in range(finish - start):
        temp = sublist_iter.next
        sublist_iter.next, temp.next, sublist_head.next = temp.next, sublist_head.next, temp
    return dummy_head.next  
\end{minted}  

Vremenska složenost zavisi od potrage za $f$-tim čvorom, tj. $O(f)$.

\textbf{Varijanta:} Napisati funkciju koja obrće jednostruko povezanu listu.
Operacija može da ima na raspolaganju samo konstantni dodatni memorijski prostor
($O(1)$).

\textbf{Varijanta:} Napisati program koji prima jednostruko spregnutu listu $L$
i nenegativni ceo broj $k$ i obrće listu po $k$ čvorova odjednom. Ako ukupan
broj čvorova u listi $n$ nije umnožak $k$, treba ostaviti poslednjih $n\mod k$
čvorova nepromenjenih. Ne treba menjati podatke koji se čuvaju u čvorovima.

\subsection{Test preklapanja listi}

Given two singly linked lists there may be list nodes that are common to both.
(This may not be a bug-it may be desirable from the perspective of reducing
memory footprint, as in the flyweight pattern, or maintaining a canonical
form.) For example, the lists in Figure \ref{fig:overlappinglists} overlap at 
Node D.

\begin{figure}[hb]
  \centering
  \begin{tikzpicture}[list/.style={
        rectangle split, 
        rectangle split parts=2,
        draw, 
        rectangle split horizontal,        
      }, 
      >=stealth, 
      start chain, 
      pin edge = {
        Straight Barb-, 
        shorten <=1mm,semithick
      },
      start chain=1,
      start chain=2
    ]
    \node[list,on chain=1,pin=180:L1] (A) {A};
    \node[list,on chain=1] (B) {B};
    \node[list,on chain=2,pin=180:L2] at (0,-1) (C) {C};
    \node[list,on chain=2] (D) {D};
    \node[list,on chain=2] (E) {E};
    \node[list,on chain=2] (F) {F};
    \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
    \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
    \draw[*->] let \p1 = (D.two), \p2 = (D.center) in (\x1,\y2) -- (E);
    \draw[*->] let \p1 = (E.two), \p2 = (E.center) in (\x1,\y2) -- (F);
    \draw let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) edge[*->,in=180,out=0,looseness=5] (D.north west);
  \end{tikzpicture}
  \caption{Primer preklapanja listi}
  \label{fig:overlappinglists}
\end{figure}

\textbf{Challenge:} Write a program that takes two cycle-free singly linked
lists, and determines if there exists a node that is common to both lists.

\textbf{Hint:} Solve the simple cases first.

\textbf{Solution:} We can avoid the extra space by using two nested loops, one
iterating through the first list, and the other to search the second for the
node being processed in the first list. However, the time complexity is
$O(n^2)$.

The lists overlap if and only if both have the same tail node: once the lists
converge at a node, they cannot diverge at a later node. Therefore, checking
for overlap amounts to finding the tail nodes for each list.

To find the first overlapping node, we first compute the length of each list.
The first overlapping node is determined by advancing through the longer list
by the difference in lengths, and then advancing through both lists in tandem,
stopping at the first common node. If we reach the end of a list without
finding a common node, the lists do not overlap.

\begin{minted}[frame=lines]{python}
def overlapping_no_cycle_lists(L1, L2):
    def length(L):
        length = 0 
        while L:
            length += 1
            L = L.next 
        return length

    L1_len, L2_len = length(L1), length(L2) 
    if L1_len > L2_len:
        L1, L2 = L2, L1  # L2 is the longer list
    # Advances the longer list to get equal length lists 
    for _ in range(abs(L1_len - L2_len)):
        L2 = L2.next

    while L1 and L2 and L1 is not L2: 
        L1, L2 = L1.next, L2.next

    return L1  # None implies there is no overlap between L1 and L2
\end{minted}

The time complexity is $O(n)$ and the space complexity is $O(1)$.

\subsection{Remove duplicates from a sorted list}

This problem is concerned with removing duplicates from a sorted list of
integers. See Figure \ref{fig:listduplicates} for an example of a list before
and after the removal of duplicates.

\begin{figure}[hb]
  \centering
  \begin{tikzpicture}[list/.style={
        rectangle split, 
        rectangle split parts=2,
        draw, 
        rectangle split horizontal,        
        prefix after command={\pgfextra{\tikzset{every label/.style={
          gray,
          below,
          yshift=-27,
          scale=0.6}}}}
      }, 
      >=stealth, 
      start chain, 
      pin edge = {
        Straight Barb-, 
        shorten <=1mm,semithick
      },
      start chain=1,
      start chain=2
    ]
    \node[list,on chain=1,pin=180:L,label=0x1000] (A) {2};
    \node[list,on chain=1,label=0x2110] (B) {2};
    \node[list,on chain=1,label=0x1830] (C) {3};
    \node[list,on chain=1,label=0x1240] (D) {5};
    \node[list,on chain=1,label=0x2200] (E) {7};
    \node[list,on chain=1,label=0x1200] (F) {11};
    \node[list,on chain=1,label=0x1354] (G) {11};
    \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
    \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
    \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
    \draw[*->] let \p1 = (D.two), \p2 = (D.center) in (\x1,\y2) -- (E);
    \draw[*->] let \p1 = (E.two), \p2 = (E.center) in (\x1,\y2) -- (F);
    \draw[*->] let \p1 = (F.two), \p2 = (F.center) in (\x1,\y2) -- (G);

    \node[list,on chain=2,pin=180:L,label=0x1000] at (0,-2) (H) {2};
    \node[list,on chain=2,label=0x1830] (I) {3};
    \node[list,on chain=2,label=0x1240] (J) {5};
    \node[list,on chain=2,label=0x2200] (K) {7};
    \node[list,on chain=2,label=0x1200] (L) {11};
    \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (I);
    \draw[*->] let \p1 = (I.two), \p2 = (I.center) in (\x1,\y2) -- (J);
    \draw[*->] let \p1 = (J.two), \p2 = (J.center) in (\x1,\y2) -- (K);
    \draw[*->] let \p1 = (K.two), \p2 = (K.center) in (\x1,\y2) -- (L);
  \end{tikzpicture}
  \caption{An example of duplicate removal}
  \label{fig:listduplicates}
\end{figure}

\textbf{Challenge:} Write a program that takes as input a singly linked list
of integers in sorted order, and removes duplicates from it. The list should
be sorted.

\textbf{Hint:} Focus on the successor fields which have to be updated.

\textbf{Solution:} A brute-force algorithm is to create a new list, using a
hash table to test if a value has already been added to the new list.
Altematively, we could search in the new list itself to see if the candidate
value already is present. If the length of the list is $n$, the first approach
requires $O(n)$ additional space for the hash table, and the second requires
$O(n^2)$ time to perform the lookups. Both allocate $n$ nodes for the new
list.

A better approach is to exploit the sorted nature of the list. As we traverse
the list, we remove all successive nodes with the same value as the current
node.

\begin{minted}[frame=lines]{python}
def remove_duplicates(L):
    it = L
    while it:
        # Uses next_distinct to find the next distinct value 
        next_distinct = it.next
        while next_distinct and next_distinct.data == it.data:
            next_distinct = next_distinct.next 
        it.next = next_distinct
        it = next_distinct
    return L  
\end{minted}

Determining the time complexity requires a little amortized analysis. A single
node may take more than $O(1)$ time to process if there are many successive
nodes with the same value. A clearer justification for the time complexity is
that each link is traversed once, so the time complexity is $O(n)$. The space
complexity is $O(1)$.

\textbf{Variant:} Let $m$ be a positive integer and $L$ a sorted singly linked
list of integers. For each integer $k$, if $k$ appears more than $m$ times in
$L$, remove all nodes from $L$ containing $k$.

\section{Stacks and Queues}

\subsection{Evaluate RPN Expressions}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\subsection{Normalize Pathnames}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\subsection{Implement a Circular Queue}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\ %

\section{Binary Trees}

Formally, a binary tree is either empty, or a \textit{root} node $r$ together
with a left binary tree and a right binary tree. The subtrees themselves are
binary trees. The left binary tree is sometimes referred to as the \textit{left
subtree} of the root, and the right binary tree is referred to as the
\textit{right subtree} of the root.

Binary trees most commonly occur in the context of binary search trees, wherein
keys are stored in a sorted fashion (Chapter X on Page Y). However, there are
many other applications of binary trees: at a high level, \textit{binary tree} are
appropriate when dealing with hierarchies. 

Figure \ref{fig:treeexample} gives a graphical representation of a binary tree.
Node $A$ is the root. Nodes $B$ and $I$ are the left and right children of $A$.

\begin{figure}[hb]
  \centering
  \begin{tikzpicture}
    [
      level 1/.style = {sibling distance = 8cm},
      level 2/.style = {sibling distance = 4cm},
      level 3/.style = {sibling distance = 2cm},
      level 4/.style = {sibling distance = 2cm},
      level 5/.style = {sibling distance = 2cm},
    ]
   
    \node[draw,label=right:A](a){314}
      child {node[draw,label=right:B](b){6}
        child {node[draw,label=right:C](c){271} 
          child {node [draw,label=right:D](d){28}} 
          child {node [draw,label=right:E] {0}}}
          child {node[draw,label=right:F] {561} 
            child {edge from parent[draw=none]} 
            child {node [draw,label=right:G] {3} 
              child {node [draw,label=right:H](h){17}} 
              child {edge from parent[draw=none]} 
            }
          }
        } 
        child {node [draw,label=right:I] {6}
          child {node [draw,label=right:J] {2}
            child {node [draw,label=right:K] {1} 
              child {node [draw,label=right:L] {401} 
                child {edge from parent[draw=none]} 
                child {node [draw,label=right:M](m){641}}
              } 
              child {node [draw,label=right:N] {257}}
            }
          }
          child {node [draw,label=right:O] {271} 
            child {edge from parent[draw=none]} 
            child {node [draw,label=right:P] {28}}
          }
      };
    \path (a) ++(3.3in,0) coordinate(a0) node [] {L0};
    \node at (b -| a0)(b0) {L1};
    \node at (c -| a0)(c0) {L2};
    \node at (d -| a0)(d0) {L3};
    \node at (h -| a0)(e0) {L4};
    \node at (m -| a0)(f0) {L5};
  \end{tikzpicture}
  \caption{Example of a binary tree. The node depths range from $0$ to $5$. Node $M$ has the highest depth $(5)$ of any node in the tree, implying the height of the tree is $5$.}
  \label{fig:treeexample}
\end{figure}

Often the node stores additional data. Its prototype is listed as follows:

\begin{minted}[frame=lines]{python}
class BinaryTreeNode:
    def __init__(self, data=None, left=None, right=None)
        self.data = data
        self.left = left
        self.right = right
\end{minted}

Each node, except the root, is itself the root of a left subtree or a right
subtree. If $l$ is the root of $p$'s left subtree, we will say $l$ is the
\textit{left child} of $p$, and $p$ is the \textit{parent} of $l$; the notion of
\textit{right child} is similar. If a node is a left or a right child of p, we
say it is a \textit{child} of p. Note that with the exception of the root, every
node has a unique parent. Usually, but not universally, the node object
definition includes a parent field (which is null for the root). Observe that
for any node there exists a unique sequence of nodes from the root to that node
with each node in the sequence being a child of the previous node. This sequence
is sometimes referred to as the \textit{search path} from the root to the node.

The parent-child relationship defines an ancestor-descendant relationship on
nodes in a binary tree. Specifically, a node is an \textit{ancestor} of $d$ il
it lies on the search path from the root to $d$. If a node is an ancestor of
$d$, we say d is a \textit{descendant} of that node. Our convention is that a
node is an ancestor and descendant of itself. A node that has no descendants
except for itself is called a \textit{leaf}.

The depth of a node $n$ is the number of nodes on the search path from the root
to $n$, not including $n$ itself. The height of a binary tree is the maximum
depth of any node in that tree. A \textit{level} of a tree is all nodes at the
same depth. See Figure \ref{fig:treeexample} for an example of the depth and
height concepts.

As concrete examples of these concepts, consider the binary tree in Figure
\ref{fig:treeexample}. Node $I$ is the parent of $J$ and $O$. Node $G$ is a
descendant of $B$. The search path to $L$ is $\langle A,I,J,K,L\rangle$. The
depth of $N$ is $4$. Node $M$ is the node of maximum depth, and hence the height
of the tree is $5$. The height of the subtree rooted at $B$ is $3$. The height
of the subtree rooted at $H$ is $0$. Nodes $D$, $E$, $H$, $M$, $N$, and $P$ are
the leaves of the tree.

A \textit{full binary tree} is a binary tree in which every node other than the
leaves has two children. A \textit{perfect binary tree} is a full binary tree in
which all leaves are at the same depth, and in which every parent has two
children. A \textit{complete binary tree} is a binary tree in which every level,
except possibly the last, is completely filled, and all nodes are as far left as
possible. (This terminology is not universal, e.g., some authors use complete
binary tree where we write perfect binary tree.) It is straightforward to prove
using induction that the number of nonleaf nodes in a full binary tree is one
less than the number of leaves. A perfect binary tree of height $h$ contains
exactly $2^{h+1} - 1$ nodes, of which $2^h$ are leaves. A complete binary tree
on $n$ nodes has height $\lfloor\log n\rfloor$. A left-skewed tree is a tree in
which no node has a right child; a right-skewed tree is a tree in which no node
has a left child. In either case, we refer to the binary tree as being skewed.

A key computation on a binary tree is \textit{traversing} all the nodes in the
tree. (Traversing is also sometimes called \textit{walking}.) Here are some ways
in which this visit can be done.

\begin{itemize}
  \item Traverse the left subtree, visit the root, then traverse the right
  subtree (an \textit{inorder} traversal). An inorder traversal of the binary
  tree in Figure \ref{fig:treeexample} visits the nodes in the following order:
  $\langle D, C, E, B, F, H, G, A, I, L, M, K, N, I, O, P\rangle$.
  \item Visit the root, traverse the left subtree, then traverse the right
  subtree (a \textit{preorder} haversal), A preorder traversal of the binary tree in
  Figure \ref{fig:treeexample} visits the nodes in the following order: $\langle A, B,
  C, D, E, E, G, H, I, J, K, L, M, N, O, P\rangle$.
  \item Traverse the left subtree, traverse the right subtree, and then visit
  the root (a \textit{postorder} traversal). A postorder traversal of the binary tree in
  Figure \ref{fig:treeexample} visits the nodes in the following order: $\langle D,
  E, C, H, G, F, B, M, L, N, K, J, P, O, I, A\rangle$.
\end{itemize}

Let $T$ be a binary tree of $n$ nodes, with height $h$. Implemented recursively, these
traversals have $O(n)$ time complexity and $O(h)$ additional space complexity. (The
space complexity is dictated by the maximum depth of the function call stack.)
If each node has a parent field, the traversals can be done with $O(1)$ additional
space complexity.

A good way to get up to speed withbinary trees is to implement the three basic
traversals---inordef, preorder, and postorder.

\begin{minted}[frame=lines]{python}
def tree_traversal(root):
    if root:
        # Preorder: Processes the root before the traversals of left and right 
        # children.
        print('Preorder: %d' % root.data)
        tree_traversal(root.left)
        # Inorder: Processes the root after the traversal of left child and 
        # before the traversal of right chiLd.
        print('Inorder : %d' % root.data)
        tree_traversal(root.right)
        # Postotder. Processes the root after the traversals of left and right 
        # children.
        print('Postorder : %d' % root . data)
\end{minted}
  
The time complexity of each approach is $O(n)$, where $n$ is the number of nodes in
the tree. Although no memory is explicitly allocated, the function call stack
reaches a maximum depth of $h$, the height of the tree. Therefore, the space
complexity is $O(h)$. The minimum value for $h$ is login (complete binary tree) and
the maximum value for $h$ is $n$ (skewed tree).

\textbf{Recursive algorithms} are well-suited to problems on trees. Remember to
include space implicitly allocated on the \textbf{function call stack} when
doing space complexity analysis. 

Some tree problems have simple brute-force solutions that use $O(n)$ space, but
subtler solutions that use the \textbf{existing tree nodes} to reduce space
complexity to $O(1)$.

Consider \textbf{left- and right-skewed trees} when doing complexity analysis.
Note that $O(h)$ complexity, where $h$ is the tree height, translates into
$O(\log n)$ complexity for balanced trees, but $O(n)$ complexity for skewed
trees.

If each node has a \textbf{parent field}, use it to make your code simpler, and
to reduce time and space complexity.

It's easy to make the \textbf{mistake} of treating a node that has a
\textbf{single child} as a leaf.

\subsection{Test If a Binary Tree is Height-balanced}

\textbf{Challenge:} A binary tree is said to be height-balanced if for each 
node in the tree, the difference in the height of its left and right subtrees 
is at most one. A perfect binary tree is height-balanced, as is a complete 
binary tree. A height-balanced binary tree does not have to be perfect or 
complete-see Figure \ref{fig:balancedtree} for an example.

Write a program that takes as input the root of a binary tree and checks 
whether the tree is height-balanced.

\textbf{Hint:} Think of a classic binary tree algorithm.

\begin{figure}[hb]
  \centering
  \begin{tikzpicture}
    [
      level 1/.style = {sibling distance = 8cm},
      level 2/.style = {sibling distance = 4cm},
      level 3/.style = {sibling distance = 2cm},
      level 4/.style = {sibling distance = 2cm},
      level 5/.style = {sibling distance = 2cm},
    ]
   
    \node[draw,label=right:A] {}
      child {node[draw,label=right:B] {}
        child {node[draw,label=right:C] {} 
          child {node [draw,label=right:D] {} 
            child {node[draw,label=right:E] {}
            } 
            child {node[draw,label=right:F] {}}
          } 
          child {node [draw,label=right:G] {}}
        }
        child {node[draw,label=right:H] {} 
          child {node[draw,label=right:I] {}} 
          child {node [draw,label=right:J] {} }
        }
      } 
      child {node [draw,label=right:K] {}
        child {node [draw,label=right:L] {}
          child {node [draw,label=right:M] {}}
          child {node [draw,label=right:N] {}}
        }
        child {node [draw,label=right:O] {}}
      };    
  \end{tikzpicture}
  \caption{A height-balanced binary tree of height $4$.}
  \label{fig:balancedtree}
\end{figure}


\textbf{Solution:} Here is a brute-force algorithm. Compute the height for the
tree rooted at each node r recursively. The basic computation is to compute the
height for each node starting from the leaves, and proceeding upwards. For each
node, we check if the difference in heights of the left and right children is
greater than one. We can store the heights in a hash table, or in a new field in
the nodes. This entails $O(n)$ storage and $O(n)$ time, where $n$ is the number
of nodes of the tree.

We can solve this problem using less storage by observing that we do not need to
store the heights of all nodes at the same time. Once we are done with a
subtree, all we need to know is whether it is height-balanced, and if so, what
its height is---we do not need any information about descendants of the
subtree's root.

The program implements a postorder traversal with some calls possibly being
eliminated because of early terminafion. Specifically, if any left subtree is
not height-balanced we do not need to visit the corresponding right subtree. The
function call stack corresponds to a sequence of calls from the root through the
unique path to the current node, and the stack height is therefore bounded by
the height of the tree, leading to an $O(h)$ space bound. The time complexity is
the same as that for a postorder traversal, namely $O(n)$.

\begin{minted}[frame=lines]{python}
def is_balanced_binary_tree(tree): 
    BalancedStatusWithHeight = collections.namedtuple(
        'BalancedStatusWithHeight', ('balanced', 'height'))

    # First value of the return value indicates if tree is balanced, and if 
    # balanced the second value of the return value is the height of tree. 
    def check_balanced(tree):
        if not tree:
            return BalancedStatusWithHeight(True, -1)  # Base case.

        left_result = check_balanced(tree.left)
        if not left_result.balanced:
            # Left subtree is not balanced.
            return BalancedStatusWithHeight(False, 0)

        right_result = check_balanced(tree.right) 
        if not right_result.balanced:
            # Right subtree is not balanced.
            return BalancedStatusWithHeight(False, 0)

        is_balanced = abs(left_result.height - right_result.height) <= 1
        height = max(left_result.height, right_result.height) + 1
        return BalancedStatusWithHeight(is_balanced, height)
    return check_balanced(tree).balanced
\end{minted}  

\textbf{Variant:} Write a program that retums the size of the largest subtree
that is complete.

\textbf{Variant:} Define a node in a binary tree to be $k$-balanced if the
difference in the number of nodes in its left and right subtrees is no more than
$k$. Design an algorithm that takes as input a binary tree and positive integer
$k$, and retums a node in the binary tree such that the node is not
$k$-balanced, but all of its descendants are $k$-balanced. For example, when
applied to the binary tree in Figure \ref{fig:treeexample}, if $k = 3$, your
algorithm should return node $J$.

\subsection{Compute the Lowest Common Ancestor in a Binary Tree}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\subsection{Sum the Root-to-leaf Paths in a Binary Tree}

Consider a binary tree in which each node contains a binary digit. A
root-to-leaf path can be associated with a binary number---the MSB is at the
root, As an example, the binary tree in Figure \ref{fig:treeencodingintegers}
represents the numbers $(1000)_2$, $(1001)_2$, $(10110)_2$, $(110011)_2$,
$(11000)_2$, and $(1100)_2$.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}
    [
      level 1/.style = {sibling distance = 8cm},
      level 2/.style = {sibling distance = 4cm},
      level 3/.style = {sibling distance = 2cm},
      level 4/.style = {sibling distance = 2cm},
      level 5/.style = {sibling distance = 2cm},
    ]
   
    \node[draw,label=right:A] {1}
      child {node[draw,label=right:B] {0}
        child {node[draw,label=right:C] {0} 
          child {node [draw,label=right:D] {0}} 
          child {node [draw,label=right:E] {1}}}
          child {node[draw,label=right:F] {1} 
            child {edge from parent[draw=none]} 
            child {node [draw,label=right:G] {1} 
              child {node [draw,label=right:H] {0}} 
              child {edge from parent[draw=none]} 
            }
          }
        } 
        child {node [draw,label=right:I] {1}
          child {node [draw,label=right:J] {0}
            child {node [draw,label=right:K] {0} 
              child {node [draw,label=right:L] {1} 
                child {edge from parent[draw=none]} 
                child {node [draw,label=right:M] {1}}
              } 
              child {node [draw,label=right:N] {0}}
            }
          }
          child {node [draw,label=right:O] {0} 
            child {edge from parent[draw=none]} 
            child {node [draw,label=right:P] {0}}
          }
      };    
  \end{tikzpicture}
  \caption{Binary tree encoding integers.}
  \label{fig:treeencodingintegers}
\end{figure}

\textbf{Challenge:} Design an algorithm to compute the sum of the binary numbers
represented by the root-to-leaf paths.

\textbf{Hint:} Thtnk of an appropriate way of traversing the tree.

\textbf{Solution:} Here is a brute-force algorithm. We compute the leaves, and
store the child-parent mapping in a hash table, e.g., via an inorder walk.
Afterwards, we traverse from each of the leaves to the root using the
child-parent map. Each leaf-to-root path yields a binary integer, with the
leaf's bit being the LSB. We sum these integers to obtain the result. The time
complexity is $O(Lh)$, where $L$ is the number of root-to-leaf paths (which
equals the number of leaves), and $h$ is the tree height. The space complexity
is dominated by the hash table, namely $O(n)$, where $n$ is the number of nodes.

The insight to improving complexity is to recognize that paths share nodes and
that it is not necessary to repeat computations across the shared nodes. To
compute the integer for the path from the root to any node, we take the integer
for the node's parent, double it, and add the bit at that node. For example the
integer for the path from $A$ to $L$ is $2 \times (1100)_2 + 1 = (11001)_2$.

Therefore, we can compute the sum of all root to leaf node as follows. Each time
we visit a node, we compute the integer it encodes using the number for its
parent. If the node is a leaf we retum its integer. If it is not a leaf, we
return the sum of the results from its left and right children.

\begin{minted}[frame=lines]{python}
def sum_root_to_leaf(tree, partial_path_sum=0) 
    if not tree:
        return 0

    partial_path_sum = partial_path_sum * 2 + tree.data 
    if not tree.left and not tree.right: # Leaf
        return partial_path_sum
    # Non-leaf
    return (sum_root_to_leaf(tree.left, partial_path_sum) + sum_root_to_leaf(
        tree.right, partial_path_sum))
\end{minted}  
  
The time complexity and space complexity are $O(n)$ and $O(h)$, respectively.

\ %

\section{Heaps}

\subsection{Merge Sorted Files}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\subsection{Compute k Closest Stars}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\subsection{Compute the Median of Streamed Data}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\ %

\section{Searching}

\subsection{Search a Sorted Array for First Occurence of k}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\subsection{Search a Sorted Array for Entry Equal to its Index}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\subsection{Find the k-th Largest Element}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 

\ %

\section{Hash Tables}

\subsection{Implement an ISBN Cache}

\textbf{Challenge:} 

\textbf{Hint:} 

\textbf{Solution:} 

\textbf{Variant:} 


\section{Sorting}

\subsection{Compute the Union of Intervals}

\ %

\section{Binary Search Trees}

\subsection{Find the First Key Greater Than a Given Value in BST}

\subsection{Build a Minimum BST From a Sorted Array}

\subsection{The Range Lookup Problem}

\ %

\section{Recursion}

\subsection{Eight Queens Puzzle}

The \emph{eight queens puzzle} is the problem of placing eight chess queens on
an 8×8 chessboard so that no two queens threaten each other; thus, a solution
requires that no two queens share the same row, column, or diagonal. The eight
queens puzzle is an example of the more general \emph{n queens problem} of
placing $n$ non-attacking queens on an $n\times n$ chessboard, for which
solutions exist for all natural numbers n with the exception of $n = 2$ and $n
= 3$.

\begin{center}
  \includegraphics[width=5cm]{8-queens.png}
\end{center}

\textbf{Challenge:} Write a program that calculates all solutions for the
eight queens puzzle.

\textbf{Hint:} Treat the problem as a state space that needs to be traversed
while looking for the solution; attempt to build a solution by adding one
queen at a time, and backtrack if needed.

\textbf{Solution:} The eight queens puzzle has 92 distinct solutions. If
solutions that differ only by the symmetry operations of rotation and
reflection of the board are counted as one, the puzzle has 12 solutions. These
are called \emph{fundamental solutions}.

A fundamental solution usually has eight variants (including its original
form) obtained by rotating 90, 180, or 270° and then reflecting each of the
four rotational variants in a mirror in a fixed position. However, should a
solution be equivalent to its own 90° rotation (as happens to one solution
with five queens on a 5×5 board), that fundamental solution will have only two
variants (itself and its reflection). Should a solution be equivalent to its
own 180° rotation (but not to its 90° rotation), it will have four variants
(itself and its reflection, its 90° rotation and the reflection of that). If n
> 1, it is not possible for a solution to be equivalent to its own reflection
because that would require two queens to be facing each other. Of the 12
fundamental solutions to the problem with eight queens on an 8×8 board,
exactly one (solution 12 below) is equal to its own 180° rotation, and none is
equal to its 90° rotation; thus, the number of distinct solutions is $11\times
8 + 1\times 4 = 92$.

The problem of finding all solutions to the 8-queens problem can be quite
computationally expensive, as there are $4,426,165,368$ (i.e., ${}_{64}C_8$)
possible arrangements of eight queens on an 8×8 board, but only 92 solutions.
It is possible to use shortcuts that reduce computational requirements or
rules of thumb that avoids brute-force computational techniques. For example,
by applying a simple rule that constrains each queen to a single column (or
row), though still considered brute force, it is possible to reduce the number
of possibilities to $16,777,216$ (that is, $8^8$) possible combinations.
Generating permutations further reduces the possibilities to just $40,320$
(that is, $8!$), which are then checked for diagonal attacks. 

A slightly more efficient solution to the puzzle uses a recursive approach:
assume that we’ve already generated all possible ways to place $k$ queens on
the first $k$ rows. In order to generate the valid positions for the $k+1$
queen we place a queen on all columns of row $k+1$ and we reject the invalid
states. We do the above steps until all eight queens are placed on the board.
This approach will generate all 92 distinct solutions for the eight queens
puzzle.

\begin{minted}[frame=lines]{python}
"""The n queens puzzle"""
class NQueens:
    """Generate all valid solutions for the n queens puzzle"""
    def __init__(self, size):
        # Store the puzzle (problem) size and the number of valid solutions
        self.size = size
        self.solutions = 0
        self.solve()

    def solve(self):
        """Solve the n queens puzzle and print the number of solutions"""
        positions = [-1] * self.size
        self.put_queen(positions, 0)
        print("Found", self.solutions, "solutions.")

    def put_queen(self, positions, target_row):
        """
        Try to place a queen on target_row by checking all N possible cases.
        If a valid place is found the function calls itself trying to place a queen
        on the next row until all N queens are placed on the NxN board.
        """
        # Base (stop) case - all N rows are occupied
        if target_row == self.size:
            self.show_full_board(positions)
            self.solutions += 1
        else:
            # For all N columns positions try to place a queen
            for column in range(self.size):
                # Reject all invalid positions
                if self.check_place(positions, target_row, column):
                    positions[target_row] = column
                    self.put_queen(positions, target_row + 1)

    def check_place(self, positions, ocuppied_rows, column):
        """
        Check if a given position is under attack from any of
        the previously placed queens (check column and diagonal positions)
        """
        for i in range(ocuppied_rows):
            if positions[i] == column or \
                positions[i] - i == column - ocuppied_rows or \
                positions[i] + i == column + ocuppied_rows:

                return False
        return True

    def show_full_board(self, positions):
        """Show the full NxN board"""
        for row in range(self.size):
            line = ""
            for column in range(self.size):
                if positions[row] == column:
                    line += "Q "
                else:
                    line += ". "
            print(line)
        print("\n")

"""Initialize and solve the n queens puzzle"""
NQueens(8)
\end{minted}

\section{Dynamic Programming}

\section{Greedy Algorithms}

\subsection{Schedule to Minimize Waiting Time}

\ %

\section{Graphs}

\subsection{Search a Maze}

\subsection{Deadlock Detection}

\ %

\section{Parallel Computing}

\subsection{Implement Caching for a Multithreaded Dictionary}

\subsection{Implement a Timer Class}

\end{document}